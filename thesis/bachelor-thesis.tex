\documentclass[times,specification,annotation]{style/itmo-student-thesis/itmo-student-thesis}

\usepackage{icomma}
\usepackage{tabularx}

\usepackage{tikz}
\usetikzlibrary{arrows}

\usepackage{filecontents}
\begin{filecontents}{bachelor-thesis.bib}
% TODO
\end{filecontents}

\addbibresource{bachelor-thesis.bib}

\begin{document}

\studygroup{M34371}
\title{Автоматизация построения программных компонентов при подготовке задач по спортивному программированию}
\author{Назаров Георгий Дмитриевич}{Назаров Г.Д.}
\supervisor{Корнеев Георгий Александрович}{Корнеев Г.А.}{доцент, к.т.н.}{доцент факультета информационных технологий и программирования}
\publishyear{2023}
\startdate{10}{апреля}{2023}
\finishdate{15}{мая}{2023}

\addconsultant{Мирзаянов М.Р.}{без степени, без звания}

\secretary{Штумпф С.А.}

\technicalspec{
    Требуется разработать систему, автоматизирующую процесс построения программных компонентов при подготовке (разработке) задач по спортивному программированию, в том числе:

    1. Спроектировать специальный язык разметки входных и выходных данных, требуемых в задаче по спортивному программированию.

    2. Реализовать систему кодогенерации, которая, на основании разметки входных и выходных данных, будет генерировать исходный код программных компонентов задачи, в том числе:

    2.1. Программы, проверяющей ответ участника (чекера);

    2.2. Программы, проверяющей корректность входных данных (валидатора);

    2.3. Компонентов ввода-вывода пользовательских решений задачи (грейдеров).

    3. Внедрить полученную систему в сервис подготовки задач по спортивному программированию «Polygon».
}

\plannedcontents{TODO}

\plannedsources{\begin{enumerate}
    \item TODO
\end{enumerate}}

\researchaim{TODO}

\researchtargets{\begin{enumerate}
    \item TODO
\end{enumerate}}

\addadvancedsoftware{TODO}{TODO}

\researchsummary{TODO}

\researchfunding{TODO}

\researchpublications{TODO}

\maketitle{Бакалавр}

\tableofcontents

\startprefacepage

Соревнования по спортивному программированию проходят с использованием автоматизированных систем тестирования, например, PCMS2, Ejudge, Яндекс.Контест, Codeforces. Участники отсылают на проверку исходный код программы-решения, которая автоматически проверяется на наборе тестов. 

Для того, чтобы задачу по спортивному программированию можно было использовать в автоматизированной тестирующей системе, авторы задачи должны предварительно подготовить <<пакет>> задачи, состоящий из условий задачи, тестов и набора программ, участвующих в процессе тестирования. Подготовка каждой задачи~--- трудоемкий ручной процесс, легко подверженный ошибкам.

В работе реализована система, позволяющая частично автоматизировать процесс подготовки задачи путем генерации некоторых  программных компонентов задачи.

% TODO: Краткое описание структуры работы вида “В Главе X рассмотрен вопрос...”

% Требуется разработать систему, автоматизирующую процесс построения программных компонентов при подготовке (разработке) задач по спортивному программированию, в том числе:

% \begin{enumerate}
% \item Спроектировать специальный язык разметки входных и выходных данных, требуемых в задаче по спортивному программированию.
% \item Реализовать систему кодогенерации, которая, на основании разметки входных и выходных данных, будет генерировать исходный код программных компонентов задачи, в том числе: программы, проверяющей ответ участника (чекера), программы, проверяющей корректность входных данных (валидатора) и компонентов ввода-вывода пользовательских решений задачи (грейдеров).
% \item Внедрить полученную систему в сервис подготовки задач по спортивному программированию <<Polygon>>.
% \end{enumerate} 

\chapter{Обзор предметной области}

% \startrelatedwork
% TODO
% \finishrelatedwork

В данной главе приводятся описания существующего процесса подготовки задач по спортивному программированию и процесса участия в соревнованиях по спортивному программированию с точки зрения участника. В дальнейшей работе будут использоваться термины и определения, вводимые в этой главе.

\section{Соревнования с точки зрения участников}

На соревнованиях по спортивному программированию участникам предлагается к решению упорядоченный набор задач. За ограниченное количество времени участники должны решить как можно больше задач и как можно точнее (определение <<точности>> зависит от правил конкретного соревнования).

К каждой задаче прилагается условие задачи~--- текстовое человекочитаемое описание требований к решению участника. Решением участника является исходный код на одном из доступных в автоматизированной системе тестирования языков программирования. Решение задачи может содержать, в зависимости от правил соревнования, как весь исходный код программы-решения, так и его часть~--- реализацию заданного в условии задачи интерфейса или функции с необходимой сигнатурой.

После проверки решения, участнику сообщается вердикт проверки~--- строка с информацией о корректности решения, возможно, содержащая дополнительную информацию, например, номер теста, на котором решение участника выдало неправильный ответ.

\section{Процесс тестирования}

После получения решения участника автоматизированная тестирующая система выполняет его обработку, состоящую из следующих основных шагов:

\begin{enumerate}
    \item Компиляция решения участника;
    \item Компоновка (линковка) решения участника с компонентами задачи (при необходимости);
    \item Генерация наборов входных данных (для генерируемых тестов);
    \item Валидация входных данных на соответствие условию задачи;
    \item Запуск исполняемого файла с решением на наборе тестов (входных данных);
    \item Запуск программы проверки ответа участника на каждом из тестов и ответов программы-решения;
\end{enumerate}

В зависимости от правил соревнования шагов может быть больше. Об ошибке на любом из шагов сообщается участнику.

\section{Подготовка задач}

Чтобы задачу можно было использовать в автоматизированной тестирующей системе, авторы задачи должны подготовить следующие компоненты задачи:

\begin{enumerate}
    \item Условия задачи, возможно, на нескольких языках;
    \item Валидатор (от англ. \textit{validator})~--- программу, принимающую на вход произвольный текстовый файл и выдающую вердикт, может ли быть этот файл использован в качестве теста в конкретной задачи. Валидатор должен проверять структуру файла и соответствие значений переменных ограничениям из условия;
    \item Чекер (от англ. \textit{checker})~--- программу, принимающую на вход тест, ответ программы участника и ответ жюри (авторского решения), и выдающая вердикт о корректности ответа участника. Чекер дожен проверять выполнение в ответе ограничений из условия задачи.
    \item Тесты (входные данные)~--- текстовые файлы, которые будут подаваться на вход решению участника. Могут быть заданы вручную или генерироваться во время тестирования;
    \item Генераторы~--- программы, принимаюцие в аргументах командной строки параметры, на основании которых генерируют (выводят) тест или набор тестов;
    \item Решение жюри (авторское решение)~--- исходный код эталонного решения задачи. Используется для получения эталонных ответов при запуске чекера;
\end{enumerate}

На некоторых соревнованиях от участников не требуется полная реализация решения, а только лишь его части~--- функции с заданной сигнатурой или интерфейса. (Подобные правила применяются, например, на IOI~--- международной олимпиаде по информатике). В таком случае авторам задачи так же необходимо подготовить грейдеры (от англ. \textit{grader}, <<оценщик>>)~--- часть исходного кода решения, которая будет скомпонована (слинкована) с решением участника. Исходный код грейдеров должен обязательно содержать точку входа программы и реализацию ввода-вывода, специфичную для задачи. Опционально, грейдеры могут выполнять дополнительные действия перед передачей управления коду участника или после окончания выполнения кода участника. Грейдеры должны быть написаны на каждом из доступных участнику языков программирования.

\section{Примеры программных компонентов задачи}

Рассмотрим подробнее программные компоненты на примере задачи <<A~+~B>>.

На листинге~\ref{a-plus-b-validator} приведен исходный код валидатора. В нем считывается два целочисленных значения в интервале от $-1000$ до $1000$, разделенных одним пробелом. Затем ожидается перевод строки и конец файла теста.

\begin{lstlisting}[float=!h,caption={Пример валидатора},label={a-plus-b-validator}]
#include "testlib.h"

int main(int argc, char *argv[])
{
    registerValidation(argc, argv);
    inf.readInt(-1000, 1000, "a");
    inf.readSpace();
    inf.readInt(-1000, 1000, "b");
    inf.readEoln();
    inf.readEof();
    return 0;
}
\end{lstlisting}

На листинге~\ref{a-plus-b-checker} приведен исходный код чекера. В нем считывается одно целочисленное значение в интервале от $-2000$ до $2000$ два раза: сначала ответ участника, затем ответ жюри (вывод авторского решения). Если ответы совпали, участник получает вердикт <<Правильный ответ>>, в противном случае <<Неправильный ответ>>, на соответствующем тесте.

\begin{lstlisting}[float=!h,caption={Пример чекера},label={a-plus-b-checker}]
#include "testlib.h"

int readAns(InStream& stream)
{
    return stream.readInt(-2000, 2000, "sum");
}

int main(int argc, char *argv[])
{
    registerTestlibCmd(argc, argv);
    int participant = readAns(ouf);
    int jury = readAns(ans);
    if (participant != jury)
        quitf(_wa, "Wrong answer");
    else
        quitf(_ok, "Ok");
}
\end{lstlisting}

Тесты могут быть сгенерированны программно. На листинге~\ref{a-plus-b-generator} приведен исходный код генератора случайных тестов. Принимает на вход единственный аргумент командной строки~--- ограничение на абсолютную величину генерируемых значений. Два случайных значения выводятся в стандартный поток вывода через пробел, затем следует перевод строки.

\begin{lstlisting}[float=!h,caption={Пример генератора},label={a-plus-b-generator}]
#include <iostream>
#include "testlib.h"
 
int main(int argc, char* argv[]) {
    registerGen(argc, argv, 1);
 
    int N = opt<int>(1);
    std::cout << rnd.next(-N, N) << ' ';
    std::cout << rnd.next(-N, N) << std::endl;
    return 0;
}
\end{lstlisting}

Грейдеры являются написанной жюри (автором задачи) частью исходного кода, который будет скомпонован с реализацией участника для получения полного исполняемого файла с решением. Грейдеры должны быть написаны на всех, доступных для использования участниками, языках программирования. 

На листинге~\ref{a-plus-b-grader-cpp} приведен исходный код грейдера для языка программирования C++. Грейдеры для C++ обычно состоят из двух файлов: заголовочного и главного. Заголовочный файл, импортируемый кодом участника, содержит определение требуемых к реализации функций и функций, написанных жюри, доступных для использования участником. Главный файл содержит точку входа (функцию \textit{main()}, с которой будет начато исполнение) и код, считывающий входные данные из стандартного потока ввода и выводящий ответ, полученный вызовом пользовательской реализации, в стандартный поток вывода.

\begin{lstlisting}[float=!h,caption={Пример грейдера для языка C++},label={a-plus-b-grader-cpp}]
// aplusb.h

int sum_ab(int a, int b);

// grader.cpp

#include <iostream>
#include "aplusb.h"
 
int main() {
    int a, b;
    std::cin >> a >> b;
    std::cout << sum_ab(a, b) << std::endl;
    return 0;
}
\end{lstlisting}

На листинге~\ref{a-plus-b-grader-py} приведен исходный код грейдера для языка программирования Python. Так как Python~--- интерпретируемый язык программирования, понятие линковки для него не определено, поэтому грейдер напрямую импортирует и вызывает решение участника. Блок кода в середине содержит проверку версии языка, чтобы грейдер мог работать как на Python 2, так и на Python 3.

\begin{lstlisting}[float=!h,caption={Пример грейдера для языка Python},label={a-plus-b-grader-py}]
import solution
import sys

if sys.version_info[0] < 3:
    _input = raw_input
else:
    _input = input
 
a, b = map(int, _input().split())
print(solution.sum_ab(a, b))
\end{lstlisting}

\section{Цели и задачи ВКР}

В предыдущих пунктах показано, что для подготовки даже простых задач по спортивному программированию авторам задачи необходимо проделать существенную работу, написав исходный код для, как минимум, трёх программных компонентов~--- валидатора, чекера и генератора, при этом генераторов может быть много, для того, чтобы сгенерировать как можно более разнообразные тесты. При этом, в случае, если задача подразумевает наличие грейдеров, объем исходного кода, необходимого к написанию, становится пропорциональным количевству поддерживаемых тестирующей системой языков программирования.

% Задание на ВКР

Основная цель данной выпускной квалификационной работы~--- разработка системы, автоматизирующей процесс реализации программных компонентнов при подготовке задач по спортивному программированию.

В ходе консультаций с авторами задач по спортивному программированию были выделены следующие задачи, решаемые в данной выпускной квалификационной работе:

\begin{enumerate}
    \item Необходимо спроектировать специальный язык разметки входных и выходных данных, специфичных для задачию.
    \item Реализовать систему кодогенерации, которая будет принимать на вход разметку входных и выходных данных, на основании которой будет частично сгенерирован исходный код валидатора, чекера и грейдеров.
    \item Внедрить реализованную систему в сервис подготовки задач по спортивному программированию <<Polygon>>.
\end{enumerate}

\startconclusionpage

TODO

\printmainbibliography

\appendix

\end{document}
